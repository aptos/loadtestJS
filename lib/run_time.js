// Generated by CoffeeScript 1.10.0
var Accumulator, ClientRequest, RunTime, Stats, http;

http = require('http');

Stats = require('./stats_model');

Accumulator = require('./accumulator');

ClientRequest = require('./client_request');

RunTime = (function() {
  function RunTime() {
    console.log("RunTime Created");
  }

  RunTime.prototype.now = function() {
    return new Date().getTime();
  };

  RunTime.prototype.ramp = function(pattern) {
    return (function(_this) {
      return function() {
        var add_requests, i, j, ref, results;
        _this.stats.duration = (_this.now() - _this.stats.start_time) / 1000;
        _this.stats.active_connections = _this.stats.requests - _this.stats.responses - _this.stats.timeouts;
        _this.totals.connections_count += 1;
        _this.totals.connections += _this.stats.active_connections;
        if (_this.stats.duration <= pattern.duration + pattern.hold) {
          if (_this.stats.volume < pattern.end) {
            _this.stats.volume = pattern.start + Math.round(_this.ramp_rate * _this.stats.duration);
          } else {
            _this.stats.volume = pattern.end;
          }
          add_requests = _this.stats.volume - _this.stats.active_connections;
          if (add_requests > 0) {
            results = [];
            for (i = j = 1, ref = add_requests; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
              results.push(_this.client.send(function() {}));
            }
            return results;
          }
        } else {
          _this.stats.volume = 0;
          if (_this.stats.duration > pattern.duration + 5 + pattern.hold) {
            _this.stats.finished = true;
            return _this.stop();
          }
        }
      };
    })(this);
  };

  RunTime.prototype.rush = function(params) {
    var pattern, ref;
    this.params = params;
    console.log("finished? " + ((ref = this.stats) != null ? ref.finished : void 0));
    this.s = new Stats();
    this.stats = this.s.stats;
    this.totals = this.s.totals;
    pattern = {
      start: parseInt(this.params.pattern.start || 1),
      end: parseInt(this.params.pattern.end || 250),
      duration: parseInt(this.params.pattern.duration || 60),
      hold: parseInt(this.params.pattern.hold || 0)
    };
    console.log(pattern);
    if (this.runId) {
      console.log("already running!");
      return {
        ok: false,
        message: "already running!"
      };
    }
    this.ramp_rate = (pattern.end - pattern.start) / pattern.duration;
    console.info("rushing... " + (JSON.stringify(this.params.request)));
    this.stats.start_time = this.now();
    this.client = new ClientRequest(this.params, this.stats, this.totals);
    this.runId = setInterval(this.ramp(pattern), 50);
    if (this.params.chart) {
      this.create_chart();
    }
    return {
      ok: true
    };
  };

  RunTime.prototype.sprint = function(params, callback) {
    var client, s;
    this.params = params;
    console.log("sprinting... " + (JSON.stringify(this.params.request)));
    s = new Stats();
    this.stats = s.stats;
    this.totals = s.totals;
    client = new ClientRequest(this.params, this.stats, this.totals);
    client.send((function(_this) {
      return function(ok) {
        var response;
        _this.stats.finished = true;
        console.log("Response: " + ok + " Stats: " + (JSON.stringify(_this.stats)));
        response = {
          ok: ok,
          data: _this.stats
        };
        return callback(void 0, response);
      };
    })(this));
  };

  RunTime.prototype.stop = function() {
    console.log("stop...");
    if (!this.runId) {
      return {
        ok: true
      };
    }
    clearInterval(this.runId);
    delete this.runId;
    this.stats.finished = true;
    this.stats.volume = 0;
    if (this.chartId) {
      clearInterval(this.chartId);
      delete this.chartId;
    }
    return {
      ok: true
    };
  };

  RunTime.prototype.create_chart = function() {
    var labels;
    labels = this.params.chart.rates.concat(this.params.chart.values.concat(this.params.chart.avg));
    this.accumulator = new Accumulator(labels);
    this.chart_data = this.accumulator.data;
    return this.chartId = setInterval(this.chart(this.params), this.params.chart.interval * 1000);
  };

  RunTime.prototype.chart = function() {
    return (function(_this) {
      return function() {
        var j, k, label, len, len1, ref, ref1;
        ref = _this.params.chart.rates;
        for (j = 0, len = ref.length; j < len; j++) {
          label = ref[j];
          _this.accumulator.push_rate(label, _this.stats.duration, _this.stats[label]);
        }
        ref1 = _this.params.chart.values;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          label = ref1[k];
          _this.accumulator.push_value(label, _this.stats.duration, _this.stats[label]);
        }
        _this.accumulator.push_avg('response_time', _this.stats.duration, _this.totals.response_time, _this.totals.response_count);
        return _this.accumulator.push_avg('active_connections', _this.stats.duration, _this.totals.connections, _this.totals.connections_count);
      };
    })(this);
  };

  return RunTime;

})();

module.exports = RunTime;

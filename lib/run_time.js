// Generated by CoffeeScript 1.3.3
var Accumulator, ClientRequest, RunTime, Stats, http;

http = require('http');

Stats = require('./stats_model');

Accumulator = require('./accumulator');

ClientRequest = require('./client_request');

RunTime = (function() {

  function RunTime() {
    console.log("RunTime Created");
  }

  RunTime.prototype.now = function() {
    return new Date().getTime();
  };

  RunTime.prototype.ramp = function(pattern) {
    var _this = this;
    return function() {
      var add_requests, i, _i, _results;
      _this.stats.duration = (_this.now() - _this.stats.start_time) / 1000;
      _this.stats.active_connections = _this.stats.requests - _this.stats.responses - _this.stats.timeouts;
      _this.totals.connections_count += 1;
      _this.totals.connections += _this.stats.active_connections;
      if (_this.stats.duration <= pattern.duration + pattern.hold) {
        if (_this.stats.volume < pattern.end) {
          _this.stats.volume = pattern.start + Math.round(_this.ramp_rate * _this.stats.duration);
        } else {
          _this.stats.volume = pattern.end;
        }
        add_requests = _this.stats.volume - _this.stats.active_connections;
        if (add_requests > 0) {
          _results = [];
          for (i = _i = 1; 1 <= add_requests ? _i <= add_requests : _i >= add_requests; i = 1 <= add_requests ? ++_i : --_i) {
            _results.push(_this.client.send(function() {}));
          }
          return _results;
        }
      } else {
        _this.stats.volume = 0;
        if (_this.stats.duration > pattern.duration + 5 + pattern.hold) {
          _this.stats.finished = true;
          return _this.stop();
        }
      }
    };
  };

  RunTime.prototype.rush = function(params) {
    var pattern, _ref;
    this.params = params;
    console.log("finished? " + ((_ref = this.stats) != null ? _ref.finished : void 0));
    this.s = new Stats();
    this.stats = this.s.stats;
    this.totals = this.s.totals;
    pattern = {
      start: parseInt(this.params.pattern.start || 1),
      end: parseInt(this.params.pattern.end || 250),
      duration: parseInt(this.params.pattern.duration || 60),
      hold: parseInt(this.params.pattern.hold || 0)
    };
    console.log(pattern);
    if (this.runId) {
      console.log("already running!");
      return {
        ok: false,
        message: "already running!"
      };
    }
    this.ramp_rate = (pattern.end - pattern.start) / pattern.duration;
    console.info("rushing... " + (JSON.stringify(this.params.request)));
    this.stats.start_time = this.now();
    this.client = new ClientRequest(this.params, this.stats, this.totals);
    this.runId = setInterval(this.ramp(pattern), 50);
    if (this.params.chart) {
      this.create_chart();
    }
    return {
      ok: true
    };
  };

  RunTime.prototype.sprint = function(params, callback) {
    var client, s,
      _this = this;
    this.params = params;
    console.log("sprinting... " + (JSON.stringify(this.params.request)));
    s = new Stats();
    this.stats = s.stats;
    this.totals = s.totals;
    client = new ClientRequest(this.params, this.stats, this.totals);
    client.send(function(ok) {
      var response;
      _this.stats.finished = true;
      console.log("Response: " + ok + " Stats: " + (JSON.stringify(_this.stats)));
      response = {
        ok: ok,
        data: _this.stats
      };
      return callback(void 0, response);
    });
  };

  RunTime.prototype.stop = function() {
    console.log("stop...");
    if (!this.runId) {
      return {
        ok: true
      };
    }
    clearInterval(this.runId);
    delete this.runId;
    this.stats.finished = true;
    this.stats.volume = 0;
    if (this.chartId) {
      clearInterval(this.chartId);
      delete this.chartId;
    }
    return {
      ok: true
    };
  };

  RunTime.prototype.create_chart = function() {
    var labels;
    labels = this.params.chart.rates.concat(this.params.chart.values.concat(this.params.chart.avg));
    this.accumulator = new Accumulator(labels);
    this.chart_data = this.accumulator.data;
    return this.chartId = setInterval(this.chart(this.params), this.params.chart.interval * 1000);
  };

  RunTime.prototype.chart = function() {
    var _this = this;
    return function() {
      var label, _i, _j, _len, _len1, _ref, _ref1;
      _ref = _this.params.chart.rates;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        _this.accumulator.push_rate(label, _this.stats.duration, _this.stats[label]);
      }
      _ref1 = _this.params.chart.values;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        label = _ref1[_j];
        _this.accumulator.push_value(label, _this.stats.duration, _this.stats[label]);
      }
      _this.accumulator.push_avg('response_time', _this.stats.duration, _this.totals.response_time, _this.totals.response_count);
      return _this.accumulator.push_avg('active_connections', _this.stats.duration, _this.totals.connections, _this.totals.connections_count);
    };
  };

  return RunTime;

})();

module.exports = RunTime;
